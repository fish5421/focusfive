/// Vulnerability demonstration tests for FocusFive markdown parser
///
/// These tests demonstrate actual parsing failures and edge cases identified
/// in the validation analysis. Each test documents specific vulnerabilities
/// and their potential impact on real-world usage.

#[cfg(test)]
mod vulnerability_demonstrations {
    use focusfive::data::parse_markdown;

    /// DEMONSTRATION 1: Header Position Dependency
    ///
    /// Real-world scenario: User creates file with editor that adds whitespace
    /// or blank lines at the beginning, or copies content from elsewhere.
    #[test]
    fn demonstrate_header_position_vulnerability() {
        // This is a perfectly valid markdown file that should parse
        let markdown_with_leading_whitespace = r#"   
# January 15, 2025 - Day 12

## Work (Goal: Ship v1)
- [x] Call investors
- [ ] Prep deck
- [ ] Team standup"#;

        let result = parse_markdown(markdown_with_leading_whitespace);
        assert!(
            result.is_err(),
            "Parser rejects valid markdown due to leading whitespace"
        );

        // This should also fail despite being logically correct
        let markdown_with_comments = r#"<!-- Generated by FocusFive -->
# January 15, 2025 - Day 12

## Work (Goal: Ship v1)  
- [x] Call investors"#;

        let result = parse_markdown(markdown_with_comments);
        assert!(
            result.is_err(),
            "Parser rejects markdown with leading comments"
        );

        println!("‚ùå VULNERABILITY: Header position dependency blocks real-world usage");
    }

    /// DEMONSTRATION 2: Silent Data Loss
    ///
    /// Real-world scenario: User accidentally adds more than 3 actions
    /// and expects an error or warning, but data is silently truncated.
    #[test]
    fn demonstrate_silent_data_truncation() {
        let markdown_with_extra_actions = r#"# January 15, 2025 - Day 12

## Work (Goal: Ship v1)
- [x] Call investors
- [ ] Prep deck  
- [ ] Team standup
- [x] Review contracts (LOST)
- [ ] Send follow-up email (LOST)
- [x] Update roadmap (LOST)"#;

        let result = parse_markdown(markdown_with_extra_actions).unwrap();

        // Only first 3 actions are stored
        assert_eq!(result.work.actions[0].text, "Call investors");
        assert_eq!(result.work.actions[1].text, "Prep deck");
        assert_eq!(result.work.actions[2].text, "Team standup");

        // The other 3 actions are completely lost without warning
        // No way to detect this happened from the API

        println!("‚ùå VULNERABILITY: 3 actions silently lost without any warning");
    }

    /// DEMONSTRATION 3: Case Sensitivity Inconsistency
    ///
    /// Real-world scenario: User types headers in different case,
    /// expecting consistent behavior but getting inconsistent parsing.
    #[test]
    fn demonstrate_case_sensitivity_inconsistency() {
        // Month names work case-insensitively
        let markdown_lowercase_month = r#"# january 15, 2025 - Day 12

## work
- [x] Task 1"#;

        let result = parse_markdown(markdown_lowercase_month);
        assert!(result.is_ok(), "Lowercase month should work");
        let goals = result.unwrap();

        // Date parsed correctly despite lowercase month
        assert_eq!(goals.date.month(), 1);

        // But action is NOT parsed due to case-sensitive outcome header
        assert_eq!(goals.work.actions[0].text, "");

        println!("‚ùå VULNERABILITY: Month case-insensitive, outcomes case-sensitive");
    }

    /// DEMONSTRATION 4: Invalid Date Acceptance  
    ///
    /// Real-world scenario: User makes typo in date, expecting validation
    /// error but getting silent acceptance of impossible date.
    #[test]
    fn demonstrate_invalid_date_acceptance() {
        // This should fail but currently succeeds due to chrono's lenient parsing
        let impossible_date = r#"# February 30, 2025 - Day 60

## Work
- [x] Task on impossible date"#;

        let result = parse_markdown(impossible_date);
        // chrono::NaiveDate::from_ymd_opt actually handles this correctly
        // and returns None for invalid dates, so this should fail
        assert!(result.is_err(), "Should reject impossible dates");

        // But this edge case might not be caught:
        let leap_year_error = r#"# February 29, 2023 - Day 60

## Work  
- [x] Task on non-leap year"#;

        let result = parse_markdown(leap_year_error);
        assert!(result.is_err(), "Should reject Feb 29 on non-leap year");

        println!("‚úÖ Date validation works, but error messages could be clearer");
    }

    /// DEMONSTRATION 5: Unicode and Special Character Issues
    ///
    /// Real-world scenario: User includes emoji, international text,
    /// or accidentally copies content with control characters.
    #[test]
    fn demonstrate_unicode_handling() {
        let markdown_with_unicode = r#"# January 15, 2025 - Day 12

## Work (Goal: Ship v1 üöÄ)
- [x] Call investors üìû
- [ ] Prep deck üìä
- [ ] Team standup ü§ù

## Health (Goal: –ó–¥–æ—Ä–æ–≤—å–µ)
- [x] Exercise üí™
- [ ] M√©ditation üßò‚Äç‚ôÇÔ∏è  
- [ ] Sleep üò¥"#;

        let result = parse_markdown(markdown_with_unicode);
        assert!(result.is_ok(), "Should handle Unicode gracefully");
        let goals = result.unwrap();

        assert_eq!(goals.work.goal, Some("Ship v1 üöÄ".to_string()));
        assert_eq!(goals.work.actions[0].text, "Call investors üìû");
        assert_eq!(goals.health.goal, Some("–ó–¥–æ—Ä–æ–≤—å–µ".to_string()));

        println!("‚úÖ Unicode handling works correctly");
    }

    /// DEMONSTRATION 6: Control Character Injection
    ///
    /// Real-world scenario: File gets corrupted or user copies text
    /// from source that includes null bytes or control characters.
    #[test]
    fn demonstrate_control_character_handling() {
        let markdown_with_control_chars = format!(
            r#"# January 15, 2025 - Day 12

## Work
- [x] Task with null byte{}here
- [ ] Task with control{}char
- [ ] Normal task"#,
            '\0', '\x01'
        );

        let result = parse_markdown(&markdown_with_control_chars);
        assert!(result.is_ok(), "Should not panic on control characters");

        if let Ok(goals) = result {
            // Control characters are preserved as-is, which might be problematic
            // for display or file system compatibility
            assert!(goals.work.actions[0].text.contains('\0'));
            println!("‚ö†Ô∏è  Control characters preserved - potential display issues");
        }
    }

    /// DEMONSTRATION 7: Regex Performance Issues
    ///
    /// Real-world scenario: Malicious input designed to cause
    /// catastrophic backtracking in regex parsing.
    #[test]
    fn demonstrate_regex_performance_vulnerability() {
        // Create input designed to stress the goal parsing regex
        let many_open_parens = "(".repeat(100);
        let malicious_goal = format!("## Work (Goal: {})", many_open_parens);
        let markdown = format!(
            r#"# January 15, 2025 - Day 12

{}
- [x] Task"#,
            malicious_goal
        );

        let start = std::time::Instant::now();
        let result = parse_markdown(&markdown);
        let duration = start.elapsed();

        // Should complete quickly, not hang
        assert!(
            duration.as_millis() < 100,
            "Regex should not cause performance issues"
        );
        assert!(result.is_ok(), "Should handle malformed goals gracefully");

        println!("‚úÖ Regex performance acceptable for this input size");
    }

    /// DEMONSTRATION 8: Memory Usage with Large Input
    ///
    /// Real-world scenario: User accidentally creates very large action text
    /// or processes generated/concatenated files.
    #[test]
    fn demonstrate_memory_usage() {
        let very_long_task = "a".repeat(10000);
        let markdown = format!(
            r#"# January 15, 2025 - Day 12

## Work
- [x] {}
- [ ] Normal task
- [ ] Another task"#,
            very_long_task
        );

        let result = parse_markdown(&markdown);
        assert!(result.is_ok(), "Should handle long text");

        if let Ok(goals) = result {
            assert_eq!(goals.work.actions[0].text.len(), 10000);
            println!("‚úÖ Large text handled, but memory usage not bounded");
        }
    }

    /// DEMONSTRATION 9: Malformed Checkbox Syntax
    ///
    /// Real-world scenario: User types similar-looking but invalid
    /// checkbox syntax, expecting it to work.
    #[test]
    fn demonstrate_checkbox_syntax_issues() {
        let markdown_with_malformed_checkboxes = r#"# January 15, 2025 - Day 12

## Work
- [x] Valid completed task
- [ ] Valid incomplete task  
- [X ] Extra space after X
- [ x] Space before x
- [y] Wrong character
- [] Missing space
* [x] Wrong bullet character
+ [x] Plus bullet
- [X]No space after bracket"#;

        let result = parse_markdown(markdown_with_malformed_checkboxes);
        assert!(result.is_ok(), "Should parse without error");

        let goals = result.unwrap();

        // Only the first 2 valid actions should be parsed
        assert_eq!(goals.work.actions[0].text, "Valid completed task");
        assert_eq!(goals.work.actions[1].text, "Valid incomplete task");
        assert_eq!(goals.work.actions[2].text, ""); // Third action empty due to malformed syntax

        println!("‚ö†Ô∏è  Malformed checkboxes silently ignored - no user feedback");
    }

    /// DEMONSTRATION 10: Outcome Header Variations
    ///
    /// Real-world scenario: User tries different header formats,
    /// expecting flexibility but getting rigid parsing.
    #[test]
    fn demonstrate_outcome_header_inflexibility() {
        let variations = vec![
            "## Work:",        // With colon
            "## Work -",       // With dash
            "##Work",          // No space
            "## WORK",         // All caps
            "## work",         // All lowercase
            "## Work Section", // Extra text
            "### Work",        // Wrong header level
        ];

        for header_variant in variations {
            let markdown = format!(
                r#"# January 15, 2025 - Day 12

{}
- [x] Test task
- [ ] Another task
- [ ] Third task"#,
                header_variant
            );

            let result = parse_markdown(&markdown);
            assert!(result.is_ok(), "Should parse without error");

            let goals = result.unwrap();
            // All these variations will fail to parse actions
            assert_eq!(
                goals.work.actions[0].text, "",
                "Header '{}' should not parse actions",
                header_variant
            );
        }

        println!("‚ùå VULNERABILITY: Inflexible header parsing rejects common variations");
    }

    /// DEMONSTRATION 11: Goal Extraction Edge Cases
    ///
    /// Real-world scenario: User writes goals with nested parentheses
    /// or special characters, expecting them to be extracted correctly.
    #[test]
    fn demonstrate_goal_extraction_issues() {
        let test_cases = vec![
            (
                "## Work (Goal: Complete project (phase 1) by Q1)",
                "Complete project (phase 1) by Q1",
            ),
            ("## Work (Goal: Earn $100k+ revenue)", "Earn $100k+ revenue"),
            (
                "## Work (Goal: Ship v2.0 & celebrate!)",
                "Ship v2.0 & celebrate!",
            ),
            ("## Work (Goal: )", ""),             // Empty goal
            ("## Work (Goal:)", ""),              // No space after colon
            ("## Work Goal: No parentheses", ""), // Wrong format
        ];

        for (header, expected_goal) in test_cases {
            let markdown = format!(
                r#"# January 15, 2025 - Day 12

{}
- [x] Task"#,
                header
            );

            let result = parse_markdown(&markdown);
            assert!(result.is_ok(), "Should parse without error");

            let goals = result.unwrap();
            let actual_goal = goals.work.goal.as_deref().unwrap_or("");

            if actual_goal != expected_goal {
                println!(
                    "‚ö†Ô∏è  Goal extraction mismatch for '{}': expected '{}', got '{}'",
                    header, expected_goal, actual_goal
                );
            }
        }
    }

    /// DEMONSTRATION 12: File Encoding Issues
    ///
    /// Real-world scenario: Files created on different platforms
    /// or with different editors may have encoding artifacts.
    #[test]
    fn demonstrate_encoding_issues() {
        // BOM (Byte Order Mark) at beginning of file
        let markdown_with_bom = "\u{FEFF}# January 15, 2025 - Day 12\n\n## Work\n- [x] Task";

        let result = parse_markdown(markdown_with_bom);
        // BOM might interfere with header parsing
        assert!(result.is_err(), "BOM should cause header parsing to fail");

        println!("‚ùå VULNERABILITY: BOM and encoding artifacts break parsing");
    }

    /// Summary demonstration showing the most critical issues
    #[test]
    fn demonstrate_critical_vulnerabilities_summary() {
        println!("\n=== CRITICAL VULNERABILITIES DEMONSTRATED ===");

        // 1. Header position dependency
        let result1 = parse_markdown("   # January 15, 2025 - Day 12\n\n## Work\n- [x] Task");
        assert!(result1.is_err());
        println!("‚ùå 1. Header position dependency: Valid markdown rejected");

        // 2. Silent data truncation
        let result2 = parse_markdown(
            "# January 15, 2025 - Day 12\n\n## Work\n- [x] 1\n- [x] 2\n- [x] 3\n- [x] 4\n- [x] 5",
        );
        assert!(result2.is_ok());
        println!("‚ùå 2. Silent data loss: 2 actions silently discarded");

        // 3. Case sensitivity inconsistency
        let result3 = parse_markdown("# january 15, 2025 - Day 12\n\n## work\n- [x] Task");
        if let Ok(goals) = result3 {
            assert_eq!(goals.work.actions[0].text, "");
            println!("‚ùå 3. Case inconsistency: Month works, outcome header doesn't");
        }

        // 4. Poor error handling
        let result4 = parse_markdown("");
        if let Err(e) = result4 {
            println!("‚ö†Ô∏è  4. Poor error message: '{}'", e);
        }

        println!("\n=== RECOMMENDATION ===");
        println!("Parser needs significant robustness improvements before production use.");
        println!("Focus on header flexibility, data validation, and clear error messages.");
    }
}

/// Performance and security demonstration tests
#[cfg(test)]
mod performance_security_tests {
    use super::*;
    use std::time::Instant;

    #[test]
    fn demonstrate_performance_characteristics() {
        // Test with increasingly large inputs
        let base_markdown = "# January 15, 2025 - Day 12\n\n## Work\n";

        for size in [100, 1000, 10000] {
            let large_content = base_markdown.to_string() + &"- [ ] Task\n".repeat(size);

            let start = Instant::now();
            let result = parse_markdown(&large_content);
            let duration = start.elapsed();

            assert!(result.is_ok(), "Should handle {} lines", size);
            println!("üìä Performance: {} lines parsed in {:?}", size, duration);

            // Performance should scale roughly linearly
            assert!(
                duration.as_millis() < size as u128,
                "Performance should be better than 1ms per line"
            );
        }
    }

    #[test]
    fn demonstrate_security_boundaries() {
        // Test extremely long single line
        let very_long_task = "x".repeat(1_000_000); // 1MB task
        let markdown = format!(
            "# January 15, 2025 - Day 12\n\n## Work\n- [x] {}",
            very_long_task
        );

        let start = Instant::now();
        let result = parse_markdown(&markdown);
        let duration = start.elapsed();

        assert!(duration.as_secs() < 1, "Should not take more than 1 second");
        assert!(result.is_ok(), "Should handle very long input");

        println!("üîí Security: 1MB task parsed in {:?}", duration);
    }
}
